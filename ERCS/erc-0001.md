---
eip: 0000
title: Verifiable Decentralized Storage (ZKStorage)
description: A minimal, composable interface that enables Ethereum smart contracts to verify ZKPs of data availability and integrity for files stored on DSNs.
author: Aryaethn (@aryaethn)
discussions-to: https://ethereum-magicians.org/t/erc-zk-storage-verifiable-decentralized-storage/0000
status: Draft
type: Standards Track
category: ERC
created: 2025-07-27
requires: 165
---

## Abstract

This ERC standardizes an interface for on-chain verification of off-chain data. It specifies:

1.  How a data commitment, an opaque `bytes32`, is referenced on-chain.
2.  How a prover submits a zero-knowledge proof (ZKP) attesting to the possession or retrievability of the data corresponding to that commitment.
3.  A generic `verifyStorage` function that allows contracts to check proofs without dependency on a specific proving system, delegating verification to scheme-specific verifiers.

The standard intentionally leaves the methods of commitment construction and the specific ZKP circuit logic out of scope.

## Motivation

Decentralized applications increasingly rely on DSNs like IPFS or Arweave for storing large assets such as NFT media, 
datasets, and web content. Currently, no canonical on-chain mechanism exists to verify that this off-chain data remains available, 
intact, and retrievable. This standard creates a crucial, interoperable bridge, allowing any contract to ask, 
“Is the data identified by commitment `X` verifiably available?” and receive a cryptographically sound answer.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", 
"MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and 
[RFC 8174](https://www.rfc-editor.org/rfc/rfc8174).

### Core Invariants

This standard's interface is concerned only with:
- An opaque `bytes32` commitment identifier.
- A `proof` and `publicInputs` byte array passed to a scheme-specific verifier.
- A `bool` result indicating verification success or failure.

The responsibility for binding the commitment to any metadata (e.g., file size, storage pointer, content type) lies entirely within the proof circuit associated with a given `schemeId`.

### Definitions

- **Commitment**: An opaque `bytes32` value that serves as a unique identifier for a dataset. This standard does not prescribe its formation.
- **DSN (Decentralized Storage Network)**: An off-chain storage layer (e.g., IPFS, Arweave, Filecoin).
- **StoragePointer**: Optional metadata describing how to locate and fetch the data from a DSN.
- **Proof**: The ZK proof bytes, whose semantics are defined by the verifier contract indicated by `schemeId`.
- **schemeId**: A `bytes4` identifier for a specific proof system and circuit combination. It is used to dispatch a verification request to the correct verifier contract.

### Interfaces

All implementing contracts **MUST** support [ERC-165](./erc-165.md).

#### Core Interface: `IERCZKStorage`

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/interfaces/IERC165.sol";

interface IERCZKStorage is IERC165 {
    struct StoragePointer {
        uint8  dsnType;   // Implementation-defined DSN identifier. 0 **MAY** signal "unknown/absent".
        bytes  locator;   // Opaque locator bytes (e.g., IPFS CID). Empty bytes **MAY** signal absence.
    }

    struct CommitmentData {
        bytes32        commitment;
        /// @dev OPTIONAL: Informational size in bytes. `type(uint256).max` **MAY** signal absence.
        uint256        size;
        /// @dev OPTIONAL: Informational storage pointer.
        ///      Both `size` and `pointer` are for off-chain UX ONLY and **MUST** NOT be relied upon
        ///      by on-chain verification logic.
        StoragePointer pointer;
    }

    struct VerificationRecord {
        uint64  blockNumber;
        uint64  timestamp;
        address prover;
        bool    success;
        bytes4  schemeId;
    }

    event CommitmentRegistered(bytes32 indexed commitment, address indexed registrant, StoragePointer pointer, uint256 size);
    event StorageVerified(bytes32 indexed commitment, address indexed prover, bool success, bytes4 schemeId);

    error CommitmentUnknown(bytes32 commitment);
    error InvalidProof(bytes reason);

    function registerCommitment(CommitmentData calldata data) external;

    function verifyStorage(
        bytes32 commitment,
        bytes4  schemeId,
        bytes calldata proof,
        bytes calldata publicInputs
    ) external returns (bool success);

    function getCommitment(bytes32 commitment) external view returns (CommitmentData memory data);

    function lastVerification(bytes32 commitment) external view returns (VerificationRecord memory rec);
}
```

### Optional Extension: `IERCZKStorageChallengeable`
To support live retrievability proofs, contracts **MAY** implement this optional extension and **MUST** advertise support via ERC-165.

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/interfaces/IERC165.sol";

interface IERCZKStorageChallengeable is IERC165 {
    event ChallengeIssued(bytes32 indexed commitment, address indexed requester, bytes challenge);

    /**
     * @notice Requests an unpredictable challenge for a given commitment.
     * @dev The returned `challenge` is intended for inclusion in the `publicInputs` of a subsequent
     * `verifyStorage` call. Implementations choose their own source of unpredictability
     * (e.g., blockhash, VRF). **MAY** revert if the commitment is unknown.
     * @param commitment The commitment for which a challenge is requested.
     * @param challengeData Arbitrary data to influence challenge generation (e.g., a nonce or difficulty hint).
     * @return challenge Opaque bytes representing the challenge.
     */
    function requestChallenge(bytes32 commitment, bytes calldata challengeData) external view returns (bytes memory challenge);
}
```

## Rationale

### Decoupling from Commitment Schemes
Leaving commitment formation out of scope is a critical design choice. 
It grants implementers the flexibility to use various cryptographic primitives 
(e.g., Poseidon, Keccak256) and to include arbitrary metadata within their commitments, 
preventing the standard from becoming a bottleneck for innovation.

### Optional Challenge-Response
Separating the challenge-response mechanism into an optional interface 
(`IERCZKStorageChallengeable`) keeps the core `IERCZKStorage` interface minimal and easy to adopt 
for static proof-of-possession use cases. It standardizes a common pattern for liveness proofs 
without imposing its complexity on all implementers.

### Verifier Indirection via `schemeId`
The use of `schemeId` to delegate verification to external contracts future-proofs the standard. 
As ZKP technology evolves, new verifiers for new schemes can be registered and used without requiring 
changes to this ERC or the contracts that consume it.

### Verifier Routing and `schemeId` Guidance
Verification is typically routed through a registry pattern.

```solidity
interface IProofVerifier {
    function verify(bytes calldata proof, bytes calldata publicInputs) external view returns (bool);
}

interface IProofVerifierRegistry {
    function getVerifier(bytes4 schemeId) external view returns (IProofVerifier);
}
```

To minimize `schemeId` collisions, the following namespace pattern is strongly recommended, though not mandated:

```solidity
bytes4 schemeId = bytes4(keccak256(abi.encodePacked(
    "erc-zk-storage.v1",
    "<CIRCUIT_NAME>",
    "<PROVER_IMPL_VERSION>"
)));
```

## Backwards Compatibility
This ERC does not conflict with any existing standards. 
Its use of ERC-165 ensures it can be composed with other standards like [ERC-721](./erc-721.md) and [ERC-1155](./erc-1155.md).

## Reference Implementation

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.20;

import "./IERCZKStorage.sol";
import "./IERCZKStorageChallengeable.sol";
import "./IProofVerifier.sol";
import "./IProofVerifierRegistry.sol";

contract ZKStorageRegistry is IERCZKStorage, IERCZKStorageChallengeable {
    mapping(bytes32 => CommitmentData) internal _commitments;
    mapping(bytes32 => VerificationRecord) internal _last;

    IProofVerifierRegistry public immutable registry;

    constructor(IProofVerifierRegistry _registry) {
        registry = _registry;
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERCZKStorage).interfaceId ||
               interfaceId == type(IERCZKStorageChallengeable).interfaceId ||
               interfaceId == type(IERC165).interfaceId;
    }

    function registerCommitment(CommitmentData calldata data) external override {
        _commitments[data.commitment] = data;
        emit CommitmentRegistered(data.commitment, msg.sender, data.pointer, data.size);
    }

    function verifyStorage(
        bytes32 commitment,
        bytes4  schemeId,
        bytes calldata proof,
        bytes calldata publicInputs
    ) external override returns (bool success) {
        if (_commitments[commitment].commitment == bytes32(0)) revert CommitmentUnknown(commitment);

        IProofVerifier verifier = registry.getVerifier(schemeId);
        success = verifier.verify(proof, publicInputs);
        if (!success) revert InvalidProof("");

        _last[commitment] = VerificationRecord({
            blockNumber: uint64(block.number),
            timestamp:   uint64(block.timestamp),
            prover:      msg.sender,
            success:     success,
            schemeId:    schemeId
        });

        emit StorageVerified(commitment, msg.sender, success, schemeId);
    }

    function getCommitment(bytes32 c) external view override returns (CommitmentData memory) {
        return _commitments[c];
    }

    function lastVerification(bytes32 c) external view override returns (VerificationRecord memory) {
        return _last[c];
    }

    // --- IERCZKStorageChallengeable ---
    function requestChallenge(bytes32 commitment, bytes calldata challengeData)
        external
        view
        override
        returns (bytes memory challenge)
    {
        if (_commitments[commitment].commitment == bytes32(0)) revert CommitmentUnknown(commitment);
        // Example: hash chainid, block.number, commitment and caller-provided data
        challenge = abi.encodePacked(keccak256(abi.encodePacked(block.chainid, block.number, commitment, challengeData)));
        emit ChallengeIssued(commitment, msg.sender, challenge);
    }
}
```

## Security Considerations

### Verifier and Registry Trust
The security of this system is fundamentally dependent on the integrity of the `IProofVerifier` and `IProofVerifierRegistry` contracts. 
A malicious or compromised verifier can approve invalid proofs. Implementers **SHOULD** treat the registry address as a critical security 
parameter, preferably making it immutable or governing it via a secure, transparent process (e.g., a DAO with a timelock).

### Metadata Binding
This interface standard does not enforce any binding between the `commitment` and its associated metadata (`size`, `pointer`, etc.). 
This binding **MUST** be enforced by the ZKP circuit logic itself. Failure to do so can lead to attacks where a proof for one piece of data 
is used for a commitment corresponding to another.

### Replay Attacks and Freshness
A valid proof of possession can be replayed indefinitely. Consumers of this interface **SHOULD** check the `timestamp` or `blockNumber` 
from the `lastVerification` record to ensure the proof is recent enough for their security requirements. 
For stronger liveness guarantees, applications should use the `IERCZKStorageChallengeable` extension and verify proofs generated in 
response to a fresh, unpredictable challenge.

###  Griefing and Denial-of-Service
Malicious actors could spam the `verifyStorage` function with invalid proofs, causing users to waste gas. 
Implementations may need to consider mitigation strategies such as requiring a small deposit from provers, rate-limiting submissions, 
or using an allowlist for provers.

### Upgradability
If the verifier or registry contracts are upgradeable, their upgrade mechanism is a critical security vector. 
An upgrade could retroactively change the validity of past proofs or compromise future ones. Such upgrades must be handled with extreme care.

## Copyright
Copyright and related rights waived via [CC0](../LICENSE.md).


